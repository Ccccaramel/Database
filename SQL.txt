**********定义与理论**********
SQL 语言分为五大类
  DDL(数据定义语言) - Create Alter Drop 这些语句自动提交,无需用 Commit 提交
  DQL(数据查询语言) - Select 查询语句不存在提交问题
  DML(数据操纵语言) - Insert Update Delete 这些语句需要 Commit 才能提交
  DTL(事务控制语言) - Commit Rollback 事务提交与回滚语句
  DCL(数据控制语言) - Grant Revoke 授予权限与回收权限语句
  执行完 DML 语句,若没有 Commit 再执行 DDL 语句,也会自动 Commit 未被 Commit 的数据
  如果打开自动提交, DML 操作后也不需要手动提交:SET AUTOCOMMIT ON;

**********SQL**********
Q:如何将一个查询结果集作为另一个查询的条件
A:table2 的 name 作为 table1的条件
    select * from table1 where name in (select name from table2)
  如果有多条语句，可以使用字段相加再等于 
    select * from table1 where fld1+fld2 in (select fld1+fld2 from table2)
  使用INNER JOIN 进行查询
    select a.* from table1 a inner join (select name from table2 group by name) b on a.name=b.name


索引
  索引的建立对于 slq 的高效运行是很重要的,索引可大大提高 sql 的检索速度,但也会降低更新表的速度,占用磁盘空间的索引文件
  索引分单列索引和组合索引
    单列索引:只包含单个列,一个表可以有多个单列索引
    组合索引:一个索引包含多个列
  索引也是一张表
  普通索引:
    最基本的索引,无任何限制
    创建索引:
       create index indexName on mytable(username(length));
    添加索引:
       alter table tableName add index indexName(columnName);
    创建表时指定:
       create table mytable(
         ID int not null,
         username varchar(16) not null,
         index [indexName] (username(length))
       );
    删除索引:
       drop index [indexName] on mytable;
  唯一索引:
    索引列的值必须唯一,但允许有空值,若为组合索引,则列值的索引必须唯一
    创建索引:
       create unique index indexName on mytable(username(length))
    修改索引:
       alter table mytable add unique [indexName] (username(length))
    创建时指定:
       create table mytable(
         ID int not null,
         username varchar(16) not null,
         unique [indexName] (username(length))
       );
    使用 alter 命令添加和删除索引
      1.添加一个主键 
         alter table mytable add primary key(column_list);
      2.创建索引的值必须是唯一的
         alter table mytable add unique indexName(column_list);
         alter table tableName add constraint indexName unique (columnName);  -- Oracle
      3.添加普通索引,索引值会出现多次
         alter table mytable add indexName(column_list);
      4.指定索引为 fulltext ,用于全文索引 
         alter table mytable add fulltext indexName(column_list);
      添加索引:
         alter table mytable add index(c);
      删除索引:
         alter table mytable drop index c;
         alter table tableName drop constraint indexName;  -- Oracle
    使用 alter 命令添加和删除主键
      添加主键索引:
         alter table table_name modify id int not null;
         alter table table_name add primary key (id);
      删除主键索引:
         alter table table_name drop primary key;
    显示索引信息:
       show index from table_name;

临时表
  临时表只在连接时可见,关闭连接时自动删除表并释放所有空间
  创建临时表:
     create temporary table t(...);
  删除临时表:
     drop table t;
  other:
     create temporary t as( select *from table_name );

复制表
  完全复制数据表,包括表的结构,索引,默认值等,仅仅使用 create table ... select 命令是无法实现的
  复制步骤:
    1.使用 show create tableName; 命令获取创建数据表语句,该语句包含了原数据表的结构,索引等
    2.复制显示的 sql 语句,修改数据表名,并执行 sql 语句,通过以上命令将完全的复制数据表结构
    3.使用 insert into ... select 语句复制表的内容
       insert into clone( table_name_id, table_name_title ) select table_name_id,table_name_title from table_name;
  另一种复制方法:
    1. create table clone like table_name;
    2. insert into clone select * from table_name;

获取服务器元数据
   select version()       服务器版本信息
   select database()      当前数据库名(或者返回空)
   select user()          当前用户名
   select status          服务器状态
   show variables         服务器配置变量

统计重复数据
   select count(*) as repetitions,Course  from table_name1 group by Course having repetitions>1; 

过滤重复数据
   select distinct Course from table_name1;

删除重复数据
  方法一:
   create table tmp select col1,col2,col3 from table_name group by (col1,col2,col3);
   drop table table_name;
   alter table tmp rename to table_name;
  方法二:
     alter ignore table table_name add primary key (col1,col2);

 sql 注入
  如果你通过网页获取用户输入的数据并将其插入数据库
  那么就有可能发生 sql 注入问题:通过 sql 命令插入到 web 表单提交或输入域名或页面请求的查询字符串,最终到达欺骗服务器执行恶意的 sql 命令
  我们必须确认用户输入的数据是安全的,必须对用户的数据进行过滤处理
  通过脚本过滤 sql 注入的字符
  防止 sql 注入需要注意以下几点:
    1.不信任用户的输入
    2.不适用动态拼接的 sql
    3.不使用管理员权限的数据库连接
    4.不把机密信息直接存放(加密)
    5.异常时少给提示,建议自定义异常
    6. sql 注入的检测方法一般采取辅助软件或网站平台来检测
      软件一般采用 sql 注入检测工具 jsky
      网站平台就有亿思网站安全平台检测工具
       MDCSOFT SCAN 等,采用 MDCSOFT-IPS 可有效防御 sql 注入, XSS 攻击等

导出数据
  普通导出:
     select * from table_name into outfile 'D:\\exe\\mysql-8.0.20-winx64\\output\\table_name.txt';
  导出 CSV 格式:
     select * from table_name into outfile '/tmp/table_name.txt' fields terminated by ',' enclosed by '"' lines terminated by '\r\n';
  自定义导出(各值用 , 隔开):
     select * into outfile '/tmp/table_name.txt' fields terminated by ',' optionally enclosed by '"' lines terminated by '\n' from table_name;

导出数据库
  导出 sql 格式的数据:
    不用登录 mysql
    直接执行 mysqldump -h localhost -u root -p ding > D:\exe\mysql-8.0.20-winx64\output\sql.txt
    会需要输入密码

导入数据
   mysql 命令导入:
     mysql -u root -p root < [要导入的数据库数据的地址];
   source 导入:
    登录 mysql
     create database [数据库名];  # 创建数据库
     use [数据库名];
     set names utf8;  # 设置编码
     source [数据库数据地址];  # 导入备份数据库
  使用 load data 导入 txt 文件数据
     load data local infile "[要导入的数据库数据的地址]" into table [导入数据的目标表名];

函数
  (略)

运算符
  (略)


 create 创建表
create table table_name(
  IDCard int unsigned auto_increment,
  Name varchar(20) not null,
  age int,
  SubmissionDate date,
  primary key (IDCard)
)engine=INNODB default charset=utf8;

create table table_name1(
  IDCard int unsigned auto_increment,
  Course varchar(20),
  grade int,
  primary key (IDCard)
)engine=INNODB default charset=utf8;
 
 drop 删除表
drop table table_name; 

 insert 插入
insert into table_name(Name,age) values ("Tom",12);
insert into table_name(Name,age) values ("Marry",22);
insert into table_name(Name,age) values ("Jim",15);
insert into table_name(Name,age) values ("Kara",32);
insert into table_name(Name,age) values ("Apple",14);
insert into table_name(Name,age) values ("Jeck",16);
insert into table_name(Name,age) values ("Sock",21);
insert into table_name(Name,age) values ("Jarry",22);
insert into table_name(Name,age) values ("Jom",18);
insert into table_name(Name,age) values ("Mara",22);
insert into table_name(Name,age) values ("Opple",14);
insert into table_name(Name,age) values ("Jack",17);
insert into table_name(Name,age) values ("Seck",25);

insert into table_name1(IDCard,Course,grade) values (1,"PHP",98);
insert into table_name1(IDCard,Course,grade) values (1,"Java",76);
insert into table_name1(IDCard,Course,grade) values (1,"HTML",94);
insert into table_name1(IDCard,Course,grade) values (2,"PHP",73);
insert into table_name1(IDCard,Course,grade) values (2,"Java",98);
insert into table_name1(IDCard,Course,grade) values (2,"HTML",86);
insert into table_name1(IDCard,Course,grade) values (3,"PHP",72);
insert into table_name1(IDCard,Course,grade) values (3,"C",75);
insert into table_name1(IDCard,Course,grade) values (3,"HTML",74);
insert into table_name1(IDCard,Course,grade) values (4,"PHP",71);
insert into table_name1(IDCard,Course,grade) values (4,"Java",96);
insert into table_name1(IDCard,Course,grade) values (4,"HTML",94);
insert into table_name1(IDCard,Course,grade) values (5,"PHP",76);
insert into table_name1(IDCard,Course,grade) values (5,"Java",70);
insert into table_name1(IDCard,Course,grade) values (6,"PHP",85);
insert into table_name1(IDCard,Course,grade) values (6,"HTML",83);
insert into table_name1(IDCard,Course,grade) values (7,"PHP",88);
insert into table_name1(IDCard,Course,grade) values (7,"Java",93);
insert into table_name1(IDCard,Course,grade) values (8,"PHP",79);
insert into table_name1(IDCard,Course,grade) values (8,"C",78);
insert into table_name1(IDCard,Course,grade) values (8,"Java",93);
insert into table_name1(IDCard,Course,grade) values (8,"HTML",85);
insert into table_name1(IDCard,Course,grade) values (9,"PHP",73);
insert into table_name1(IDCard,Course,grade) values (9,"C",84);

insert ignore into 插入 > mysql
#如果插入数据库已存在的数据就会跳过这条语句,若没有就插入
insert ignore into table_name1(IDCard,Course,grade) values (9,"C",84);

 replace into 替换
需求表中有 PrimaryKey ,或 unique 
如果数据库已经存在数据,则用新数据替换
如果没有数据效果则和 insert into 一样
 REPLACE 语句会返回一个数来指示受影响的行的数目
该数是被删除和被插入的行数的和,如果对于一个单行 REPLACE 该数为1,则一行被插入同时没有行被删除
如果该数大于1,则在新行被插入前,有一个或多个旧行被删除
如果表包含多个唯一索引,并且新行复制了在不同的唯一索引中的不同旧行的值,则有可能是一个单一行替换了多个旧行
replace into table_nametb(id,name,age)values(1,"aa",12);

delete 删除数据
delete from table_name where IDCard=4;

 binary 关键字
select * from table_name where binary name='tom';  # 区分大小写

 update 更新
update table_name set age=100 where IDCard=2;
update table_name set age=age+1;  # 所有人 age 属性值+1

删除列
alter table tableName drop column columnName

 replace 替换
update table_name set age=replace(age,100,23) where IDCard>=1;

 union 操作符
# 将两个以上的 select 语句结果组合到一个结果结合中
# distinct 为可选参数,删除结果中重复的数据,若不加参数默认情况下同为此效果,可使用 all 参数显示全部数据
select Name from table_name where Name like "%m" union distinct select Name from table_name where age>15;

 group by 分组
select age,count(*) from table_name group by age;  # 各个年龄的人数
select coalesce(name,"总数"),sum(age) as count from table_name group by name with rollup;  # 年龄和

* join 笛卡尔积
  连接两张表,大致可分为内连接,外连接,右连接,左连接,自然连接
    select * from table1 a left join table2 b on a.key=b.key;    -- 左连接
    select * from table1 a inner join table2 b on a.key=b.key;   -- 内连接,交集
    select * from table1 a right join table2 b on a.key=b.key;   -- 右连接
    select * from table1 a left join table2 b on a.key=b.key where b.key is NULL;    -- 左连接-交集
    select * from table1 a right join table2 b on a.key=b.key where a.key is NULL;   -- 右连接-交集
    select * from table1 a full outer join table2 b on a.key=b.key;  -- 外连接,并集
    select * from table1 a full outer join table2 b on a.key=b.key where a.key is NULL or b.key is NULL;  -- 并集-交集
  内连接
    四种写法: inner join , where(等值连接) , straight_join , join(省略 inner )
    select * from table1 a inner join table2 b on a.id=b.id;
    select * from table1 a,table2 b where a.id=b.id;
    select * from table1 a straight_join table2 b on a.id=b.id;  --冷门很少用
    select * from table1 a join table2 b on a.id=b.id;
    Q:内连接的四种写法中那种最优呢?
  自然连接
     nature join
    自然连接可理解为 using 子句的简化版,它找出两个表中相同的列作为连接条件进行连接
    有左自然连接,右自然连接,普通自然连接
    找不同
      自然连接:SELECT * FROM t_blog NATURAL JOIN t_type;
      笛卡尔积:SELECT * FROM t_blog NATURA JOIN t_type;
      笛卡尔积:SELECT * FROM t_blog NATURE JOIN t_type;

using 子句
在连接 sql 语句中, on 子句的语法格式为 a.id=b.id 
当模式设计对连接表的列采用相同的命名样式时,就可以使用 using 语法来简化 on 语法,格式为: using(columnName);
即 using 的功能相当于 on ,区别在于 using 指定一个属性名用于连接两个表,而 on 指定一个条件
除此之外, select * 时 using 会除去 using 的列,而 on 不会

 join 原理
   Nested Loop Join(NLJ) 算法
    嵌套循环算法,循环外层是驱动表,内层是被驱动表
    驱动表会驱动被驱动表进行连接操作
    首先驱动表找到第一条记录,然后从头扫描被驱动表,逐一查找与驱动表第一条记录匹配的记录,然后连接起来形成结果表中的一条记录
    被驱动表查找完后再从驱动表中取出第二条记录,然后从头扫描被驱动表,逐一查找与驱动表第二条记录匹配的记录,连接起来形成结果表的第二条记录
    重复上述操作,直到驱动表的全部记录都处理完毕为止,这就是嵌套循环连接算法的基本思想,伪代码如下:
      foreach row1 from t1
          foreach row2 from t2
              if row2 match row1 //row2与row1匹配，满足连接条件
                  join row1 and row2 into result //连接row1和row2加入结果集
   Block Nested Loop Join(BNLJ) 算法
    块嵌套循环算法,可看作对 NLJ 的优化
    大致思想就是建立一个缓存区,一次从驱动表中取出多条记录,然后扫描被驱动表
    被驱动表的每条记录都尝试与缓存区中的多条记录匹配,如果存在则连接并加入结果集
    缓冲区越大,驱动表一次取出的记录就越多
    这个算法的优化思路就是减少内循环的次数从而提高表连接效率
  影响性能的因素
    <1>内循环的次数
      现在考虑这么一个场景,表t1有100条记录,表t2有10000条记录
      那么t1驱动t2与t2驱动t1,它们之间再效率上孰优孰劣?如果单纯的分析指令执行次数,他们都是100*10000
      但考虑到加载表的次数呢?首先分析t1驱动t2,t1表加载1次,t2表需要加载100次
      反过来分析t2驱动t1,t2表首先加载1次,但是t1表要加载10000次,所以,t1驱动t2的效率要优于t2驱动t1的效率
      由此得出,小表驱动大表能够减少内循环的次数从而提高连接效率
      此外,如果使用 BNLJ 算法通过扩大一次缓存区的大小也能减小内循环的次数
      由此可得,设置合理的缓冲区大小能够提高连接效率
      扫描被驱动表寻找合适的记录可看作一个查询操作,而建立索引可提高查询效率
      由此可得,在被驱动表建立索引能够提高连接效率
      假设t1表驱动t2表进行连接操作,连接条件t1.id=t2.id,而且要求查询结果对id排序
      现在有两种选择
      方式一:[ ... order by t1.id ]
      方式二:[ ... order by t2.id ]
      若用方式一,可以先对t1进行排序然后执行表连接算法
      若用方式二,只能在执行表连接算法后对结果进行排序,效率自然低下
      由此可得,优先选择驱动表的属性进行排序能提高连接效率
  优化内循环的次数
    内循环的次数受驱动表的记录数所影响,驱动表记录数越多,内循环就越多,连接效率就越低,所以尽量小表驱动大表
    但是表的记录数是会变化的,是否存在一劳永逸的写法呢?
     mysql 自带的 Optimizer 会优化内连接,优化策略就是小表驱动大表,所以以后内连接不要纠结谁内连接谁了,直接让 mysql 去判断吧
  优化扫描速度
    建立索引
    在左连接中,左表是驱动表,右表是被驱动表,想要快速查找被驱动表中匹配的记录,可在右表中建索引从而提高连接性能
    在右连接中,右表是驱动表,左表是被驱动表,想要快速查找被驱动表中匹配的记录,可在左表中建索引从而提高连接性能
    在内连接中, mysql Optimizer 会对内连接做优化,不管谁内连接谁,都是小表驱动大表
    所以如果要优化内连接,可以在大表上建立索引以提高性能,在小表上建立索引时, mysql Optimizer 会认为用大表驱动小表效率更快,转而用大表驱动小表
    想要从快速匹配的角度优化 join ,首先就是找出谁是驱动表,谁是被驱动表,然后在被驱动表上建立索引即可

 order by 排序
select * from table_name order by age ASC;  # 升序
select * from table_name order by age DESC;  # 降序

 where 条件
select * from table_name where age>=16;

 like 模糊匹配
select * from table_name where Name like '%m';  # 以 m 结尾
select * from table_name where Name like 'J%';  # 以 J 开头
select * from table_name where Name like '_i_';  # 三位且中间为 i 
(更多见正则表达式)

 NULL 处理
select *,age+ifnull(SubmissionDate,100) from table_name;  // 若值为 NULL 则用指定值代替

正则表达式
 mysql 既可以通过 like...% 来进行模糊匹配,同样也支持正则表达式匹配
 mysql 使用 regexp 操作符来进行正则表达式匹配
 regexp 操作符
^          匹配输入字符串的开始位置
$          匹配输入字符串的结束位置
.          匹配除 \n 之外的任何单一字符 
[]         字符集合,匹配包含的任意一个字符
[^]        负值字符集合,匹配未包含的任意一个字符
|          或
*          匹配前面的子表达式零次或多次
+          匹配前面的子表达式一次或多次 
{n}         n 为非负整数,匹配 n 次
{n,m}       m 和 n 均为非负整数,其中 n<=m ,最少匹配 n 次且最多匹配 m 次
eg:
select Name from table_name where Name regexp '^J';
select Name from table_name where Name regexp 'k$';
select Name from table_name where Name regexp 'ar';

 alter 命令
--删除列
> MYSQL,ORACLE
   alter table table_name drop column column_name;
--增加列
> MYSQL,ORACLE
   alter table table_name add column_name column_type [default column_value [not null]];
--更改列名,也可使用 change
> MYSQL
   alter table table_name modify old_column_name new_column_name new_column_type;
> ORACLE
   alter table table_name column old_column_name to new_column_name;
   alter table table_name modify (column_name column_type);
--列类型更改
> MYSQL
   alter table table_name modify column_name new_column_type;
> ORACLE
   alter table table_name modify (column_name column_type);
--更改列类型以及默认值
> MYSQL
   alter table table_name change column_name column_type not null default column_value;
--更改默认值
> MYSQL
   alter table table_name alter column_name set default column_value;
--删除默认值
> MYSQL
   alter table table_name alter column_name drop default;
--更改表类型
> MYSQL
   eg:alter table table_name engine=myisam;  # 将 table_name 表的类型更改为 myisam
--修改表名
> MYSQL
   alter table table_name rename to new_table_name;
--添加外键
> ORACLE
  alter table A_table_name add constraint fk_name foreign key(A_column_name) references B_table_name(B_column_name);
--删除外键
> MYSQL
   alter table table_name drop foreign key column_name;
> ORACLE
   alter table table_name drop constraint fk_name;

 auto_increment 自增序列
create table table_name(
  id int unsigned not null auto_increment;
);  # 创建表时设置为自增列,默认从1开始
create table table_name(
  id int unsigned not null auto_increment;
)engine=innodb auto_increment=100 charset=utf8;  # 从100开始
alter table table_name id auto_increment=100;  # 从100开始
#重置序列
   alter table table_name drop id;
   alter table table_name add id int unsigned not null auto_increment first,add primary key (id);

 > Oracle
select * from all_tab_comments       查询所有用户的表,视图等
select * from user_tab_comments      查询本用户的表,视图等
select * from all_col_comments       查询所有用户的表的列名和注释
select * from user_col_comments      查询本用户的表的列名和注释
select * from all_tab_columns        查询所有用户的表的列名等信息
select * from user_tab_columns       查询本用户的表的列名等信息

Q: => 的含义
A: => 是 Oracle 中调用存储过程的时候指定参数名进行调用
  一般指某些参数有默认值的时候你需要跳过某些参数来进行调用
  eg:
    CREATE OR REPLACE PROCEDURE HelloWorld3 (
        p_user_name VARCHAR2,
        p_val1 VARCHAR2 DEFAULT ' Good Moning,',
        p_val2 VARCHAR2 DEFAULT ' Nice to Meet you'
    )
    AS BEGIN
    dbms_output.put_line('Hello ' || p_user_name || p_val1 || p_val2 || '!');
    END HelloWorld3;

--查询指定条数的数据 > Oracle
SELECT * FROM customer WHERE ROWNUM < 101