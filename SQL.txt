**********定义与理论**********
SQL 语言分为五大类
  DDL(数据定义语言) - Create Alter Drop 这些语句自动提交,无需用 Commit 提交
  DQL(数据查询语言) - Select 查询语句不存在提交问题
  DML(数据操纵语言) - Insert Update Delete 这些语句需要 Commit 才能提交
  DTL(事务控制语言) - Commit Rollback 事务提交与回滚语句
  DCL(数据控制语言) - Grant Revoke 授予权限与回收权限语句
  执行完 DML 语句,若没有 Commit 再执行 DDL 语句,也会自动 Commit 未被 Commit 的数据
  如果打开自动提交, DML 操作后也不需要手动提交:SET AUTOCOMMIT ON;


**********SQL**********
Q:如何将一个查询结果集作为另一个查询的条件
A:table2 的 name 作为 table1的条件
    select * from table1 where name in (select name from table2)
  如果有多条语句，可以使用字段相加再等于 
    select * from table1 where fld1+fld2 in (select fld1+fld2 from table2)
  使用INNER JOIN 进行查询
    select a.* from table1 a inner join (select name from table2 group by name) b on a.name=b.name


索引
  索引的建立对于 slq 的高效运行是很重要的,索引可大大提高 sql 的检索速度,但也会降低更新表的速度,占用磁盘空间的索引文件
  索引分单列索引和组合索引
    单列索引:只包含单个列,一个表可以有多个单列索引
    组合索引:一个索引包含多个列
  索引也是一张表
  普通索引:
    最基本的索引,无任何限制
    创建索引:
       create index indexName on mytable(username(length));
    添加索引:
       alter table tableName add index indexName(columnName);
    创建表时指定:
       create table mytable(
         ID int not null,
         username varchar(16) not null,
         index [indexName] (username(length))
       );
    删除索引:
       drop index [indexName] on mytable;
  唯一索引:
    索引列的值必须唯一,但允许有空值,若为组合索引,则列值的索引必须唯一
    创建索引:
       create unique index indexName on mytable(username(length))
    修改索引:
       alter table mytable add unique [indexName] (username(length))
    创建时指定:
       create table mytable(
         ID int not null,
         username varchar(16) not null,
         unique [indexName] (username(length))
       );
    使用 alter 命令添加和删除索引
      1.添加一个主键 
         alter table mytable add primary key(column_list);
      2.创建索引的值必须是唯一的
         alter table mytable add unique indexName(column_list);
      3.添加普通索引,索引值会出现多次
         alter table mytable add indexName(column_list);
      4.指定索引为 fulltext ,用于全文索引 
         alter table mytable add fulltext indexName(column_list);
      添加索引:
         alter table mytable add index(c);
      删除索引:
         alter table mytable drop index c;
    使用 alter 命令添加和删除主键
      添加主键索引:
         alter table test modify id int not null;
         alter table test add primary key (id);
      删除主键索引:
         alter table test drop primary key;
    显示索引信息:
       show index from test;

临时表
  临时表只在连接时可见,关闭连接时自动删除表并释放所有空间
  创建临时表:
     create temporary table t(...);
  删除临时表:
     drop table t;
  other:
     create temporary t as( select *from test );

复制表
  完全复制数据表,包括表的结构,索引,默认值等,仅仅使用 create table ... select 命令是无法实现的
  复制步骤:
    1.使用 show create tableName; 命令获取创建数据表语句,该语句包含了原数据表的结构,索引等
    2.复制显示的 sql 语句,修改数据表名,并执行 sql 语句,通过以上命令将完全的复制数据表结构
    3.使用 insert into ... select 语句复制表的内容
       insert into clone( test_id, test_title ) select test_id,test_title from test;
  另一种复制方法:
    1. create table clone like test;
    2. insert into clone select * from test;

获取服务器元数据
   select version()       服务器版本信息
   select database()      当前数据库名(或者返回空)
   select user()          当前用户名
   select status          服务器状态
   show variables         服务器配置变量

统计重复数据
   select count(*) as repetitions,Course  from test1 group by Course having repetitions>1; 

过滤重复数据
   select distinct Course from test1;

删除重复数据
  方法一:
   create table tmp select col1,col2,col3 from test group by (col1,col2,col3);
   drop table test;
   alter table tmp rename to test;
  方法二:
     alter ignore table test add primary key (col1,col2);

 sql 注入
  如果你通过网页获取用户输入的数据并将其插入数据库
  那么就有可能发生 sql 注入问题:通过 sql 命令插入到 web 表单提交或输入域名或页面请求的查询字符串,最终到达欺骗服务器执行恶意的 sql 命令
  我们必须确认用户输入的数据是安全的,必须对用户的数据进行过滤处理
  通过脚本过滤 sql 注入的字符
  防止 sql 注入需要注意以下几点:
    1.不信任用户的输入
    2.不适用动态拼接的 sql
    3.不使用管理员权限的数据库连接
    4.不把机密信息直接存放(加密)
    5.异常时少给提示,建议自定义异常
    6. sql 注入的检测方法一般采取辅助软件或网站平台来检测
      软件一般采用 sql 注入检测工具 jsky
      网站平台就有亿思网站安全平台检测工具
       MDCSOFT SCAN 等,采用 MDCSOFT-IPS 可有效防御 sql 注入, XSS 攻击等

导出数据
  普通导出:
     select * from test into outfile 'D:\\exe\\mysql-8.0.20-winx64\\output\\test.txt';
  导出 CSV 格式:
     select * from test into outfile '/tmp/test.txt' fields terminated by ',' enclosed by '"' lines terminated by '\r\n';
  自定义导出(各值用 , 隔开):
     select * into outfile '/tmp/test.txt' fields terminated by ',' optionally enclosed by '"' lines terminated by '\n' from test;

导出数据库
  导出 sql 格式的数据:
    不用登录 mysql
    直接执行 mysqldump -h localhost -u root -p ding > D:\exe\mysql-8.0.20-winx64\output\sql.txt
    会需要输入密码

导入数据
   mysql 命令导入:
     mysql -u root -p root < [要导入的数据库数据的地址];
   source 导入:
    登录 mysql
     create database [数据库名];  # 创建数据库
     use [数据库名];
     set names utf8;  # 设置编码
     source [数据库数据地址];  # 导入备份数据库
  使用 load data 导入 txt 文件数据
     load data local infile "[要导入的数据库数据的地址]" into table [导入数据的目标表名];

函数
  (略)

运算符
  (略)


 create 创建表
create table test(
  IDCard int unsigned auto_increment,
  Name varchar(20) not null,
  age int,
  SubmissionDate date,
  primary key (IDCard)
)engine=INNODB default charset=utf8;

create table test1(
  IDCard int unsigned auto_increment,
  Course varchar(20),
  grade int,
  primary key (IDCard)
)engine=INNODB default charset=utf8;
 
 drop 删除表
drop table test; 

 insert 插入
insert into test(Name,age) values ("Tom",12);
insert into test(Name,age) values ("Marry",22);
insert into test(Name,age) values ("Jim",15);
insert into test(Name,age) values ("Kara",32);
insert into test(Name,age) values ("Apple",14);
insert into test(Name,age) values ("Jeck",16);
insert into test(Name,age) values ("Sock",21);
insert into test(Name,age) values ("Jarry",22);
insert into test(Name,age) values ("Jom",18);
insert into test(Name,age) values ("Mara",22);
insert into test(Name,age) values ("Opple",14);
insert into test(Name,age) values ("Jack",17);
insert into test(Name,age) values ("Seck",25);

insert into test1(IDCard,Course,grade) values (1,"PHP",98);
insert into test1(IDCard,Course,grade) values (1,"Java",76);
insert into test1(IDCard,Course,grade) values (1,"HTML",94);
insert into test1(IDCard,Course,grade) values (2,"PHP",73);
insert into test1(IDCard,Course,grade) values (2,"Java",98);
insert into test1(IDCard,Course,grade) values (2,"HTML",86);
insert into test1(IDCard,Course,grade) values (3,"PHP",72);
insert into test1(IDCard,Course,grade) values (3,"C",75);
insert into test1(IDCard,Course,grade) values (3,"HTML",74);
insert into test1(IDCard,Course,grade) values (4,"PHP",71);
insert into test1(IDCard,Course,grade) values (4,"Java",96);
insert into test1(IDCard,Course,grade) values (4,"HTML",94);
insert into test1(IDCard,Course,grade) values (5,"PHP",76);
insert into test1(IDCard,Course,grade) values (5,"Java",70);
insert into test1(IDCard,Course,grade) values (6,"PHP",85);
insert into test1(IDCard,Course,grade) values (6,"HTML",83);
insert into test1(IDCard,Course,grade) values (7,"PHP",88);
insert into test1(IDCard,Course,grade) values (7,"Java",93);
insert into test1(IDCard,Course,grade) values (8,"PHP",79);
insert into test1(IDCard,Course,grade) values (8,"C",78);
insert into test1(IDCard,Course,grade) values (8,"Java",93);
insert into test1(IDCard,Course,grade) values (8,"HTML",85);
insert into test1(IDCard,Course,grade) values (9,"PHP",73);
insert into test1(IDCard,Course,grade) values (9,"C",84);

insert ignore into 插入 > mysql
#如果插入数据库已存在的数据就会跳过这条语句,若没有就插入
insert ignore into test1(IDCard,Course,grade) values (9,"C",84);

 replace into 替换
需求表中有 PrimaryKey ,或 unique 
如果数据库已经存在数据,则用新数据替换
如果没有数据效果则和 insert into 一样
 REPLACE 语句会返回一个数来指示受影响的行的数目
该数是被删除和被插入的行数的和,如果对于一个单行 REPLACE 该数为1,则一行被插入同时没有行被删除
如果该数大于1,则在新行被插入前,有一个或多个旧行被删除
如果表包含多个唯一索引,并且新行复制了在不同的唯一索引中的不同旧行的值,则有可能是一个单一行替换了多个旧行
replace into testtb(id,name,age)values(1,"aa",12);

delete 删除数据
delete from test where IDCard=4;

 binary 关键字
select * from test where binary name='tom';  # 区分大小写

 update 更新
update test set age=100 where IDCard=2;
update test set age=age+1;  # 所有人 age 属性值+1

删除列
alter table tableName drop column columnName

 replace 替换
update test set age=replace(age,100,23) where IDCard>=1;

 union 操作符
# 将两个以上的 select 语句结果组合到一个结果结合中
# distinct 为可选参数,删除结果中重复的数据,若不加参数默认情况下同为此效果,可使用 all 参数显示全部数据
select Name from test where Name like "%m" union distinct select Name from test where age>15;

 group by 分组
select age,count(*) from test group by age;  # 各个年龄的人数
select coalesce(name,"总数"),sum(age) as count from test group by name with rollup;  # 年龄和

* join 笛卡尔积
  连接两张表,大致可分为内连接,外连接,右连接,左连接,自然连接
    select * from table1 a left join table2 b on a.key=b.key;    -- 左连接
    select * from table1 a inner join table2 b on a.key=b.key;   -- 内连接,交集
    select * from table1 a right join table2 b on a.key=b.key;   -- 右连接
    select * from table1 a left join table2 b on a.key=b.key where b.key is NULL;    -- 左连接-交集
    select * from table1 a right join table2 b on a.key=b.key where a.key is NULL;   -- 右连接-交集
    select * from table1 a full outer join table2 b on a.key=b.key;  -- 外连接,并集
    select * from table1 a full outer join table2 b on a.key=b.key where a.key is NULL or b.key is NULL;  -- 并集-交集
  内连接
    四种写法: inner join , where(等值连接) , straight_join , join(省略 inner )
    select * from table1 a inner join table2 b on a.id=b.id;
    select * from table1 a,table2 b where a.id=b.id;
    select * from table1 a straight_join table2 b on a.id=b.id;
    select * from table1 a join table2 b on a.id=b.id;
    Q:内连接的四种写法中那种最优呢?
  自然连接
     nature join
    自然连接可理解为 using 子句的简化版,它找出两个表中相同的列作为连接条件进行连接
    有左自然连接,右自然连接,普通自然连接
    找不同
      自然连接:SELECT * FROM t_blog NATURAL JOIN t_type;
      笛卡尔积:SELECT * FROM t_blog NATURA JOIN t_type;
      笛卡尔积:SELECT * FROM t_blog NATURE JOIN t_type;

using 子句
在连接 sql 语句中, on 子句的语法格式为 a.id=b.id 
当模式设计对连接表的列采用相同的命名样式时,就可以使用 using 语法来简化 on 语法,格式为: using(columnName);
即 using 的功能相当于 on ,区别在于 using 指定一个属性名用于连接两个表,而 on 指定一个条件
除此之外, select * 时 using 会除去 using 的列,而 on 不会

 join 原理
   Nested Loop Join(NLJ) 算法
    嵌套循环算法,循环外层是驱动表,内层是被驱动表
    驱动表会驱动被驱动表进行连接操作
    首先驱动表找到第一条记录,然后从头扫描被驱动表,逐一查找与驱动表第一条记录匹配的记录,然后连接起来形成结果表中的一条记录
    被驱动表查找完后再从驱动表中取出第二条记录,然后从头扫描被驱动表,逐一查找与驱动表第二条记录匹配的记录,连接起来形成结果表的第二条记录
    重复上述操作,直到驱动表的全部记录都处理完毕为止,这就是嵌套循环连接算法的基本思想,伪代码如下:
      foreach row1 from t1
          foreach row2 from t2
              if row2 match row1 //row2与row1匹配，满足连接条件
                  join row1 and row2 into result //连接row1和row2加入结果集
   Block Nested Loop Join(BNLJ) 算法
    块嵌套循环算法,可看作对 NLJ 的优化
    大致思想就是建立一个缓存区,一次从驱动表中取出多条记录,然后扫描被驱动表
    被驱动表的每条记录都尝试与缓存区中的多条记录匹配,如果存在则连接并加入结果集
    缓冲区越大,驱动表一次取出的记录就越多
    这个算法的优化思路就是减少内循环的次数从而提高表连接效率
  影响性能的因素
    <1>内循环的次数
      现在考虑这么一个场景,表t1有100条记录,表t2有10000条记录
      那么t1驱动t2与t2驱动t1,它们之间再效率上孰优孰劣?如果单纯的分析指令执行次数,他们都是100*10000
      但考虑到加载表的次数呢?首先分析t1驱动t2,t1表加载1次,t2表需要加载100次
      反过来分析t2驱动t1,t2表首先加载1次,但是t1表要加载10000次,所以,t1驱动t2的效率要优于t2驱动t1的效率
      由此得出,小表驱动大表能够减少内循环的次数从而提高连接效率
      此外,如果使用 BNLJ 算法通过扩大一次缓存区的大小也能减小内循环的次数
      由此可得,设置合理的缓冲区大小能够提高连接效率
      扫描被驱动表寻找合适的记录可看作一个查询操作,而建立索引可提高查询效率
      由此可得,在被驱动表建立索引能够提高连接效率
      假设t1表驱动t2表进行连接操作,连接条件t1.id=t2.id,而且要求查询结果对id排序
      现在有两种选择
      方式一:[ ... order by t1.id ]
      方式二:[ ... order by t2.id ]
      若用方式一,可以先对t1进行排序然后执行表连接算法
      若用方式二,只能在执行表连接算法后对结果进行排序,效率自然低下
      由此可得,优先选择驱动表的属性进行排序能提高连接效率



 order by 排序
select * from test order by age ASC;  # 升序
select * from test order by age DESC;  # 降序

 where 条件
select * from test where age>=16;

 like 模糊匹配
select * from test where Name like '%m';  # 以 m 结尾
select * from test where Name like 'J%';  # 以 J 开头
select * from test where Name like '_i_';  # 三位且中间为 i 
(更多见正则表达式)

 NULL 处理
select *,age+ifnull(SubmissionDate,100) from test;  // 若值为 NULL 则用指定值代替

正则表达式
 mysql 既可以通过 like...% 来进行模糊匹配,同样也支持正则表达式匹配
 mysql 使用 regexp 操作符来进行正则表达式匹配
 regexp 操作符
^          匹配输入字符串的开始位置
$          匹配输入字符串的结束位置
.          匹配除 \n 之外的任何单一字符 
[]         字符集合,匹配包含的任意一个字符
[^]        负值字符集合,匹配未包含的任意一个字符
|          或
*          匹配前面的子表达式零次或多次
+          匹配前面的子表达式一次或多次 
{n}         n 为非负整数,匹配 n 次
{n,m}       m 和 n 均为非负整数,其中 n<=m ,最少匹配 n 次且最多匹配 m 次
eg:
select Name from test where Name regexp '^J';
select Name from test where Name regexp 'k$';
select Name from test where Name regexp 'ar';

 alter 命令
# 当需要修改数据表名或修改数据表字段时
alter table test drop SubmissionDate Data;  # 删除 SubmissionDate 列
alter talbe test add heigh int;  # 增加一个名为 heigh 列且类型为 int
alter talbe test modify heigh weight bigint;  # 将 heigh 列更名为 weight ,类型更改为 bigint , modify 也可使用 change
alter talbe test modify heigh heigh bigint;  # 将 heigh 列的类型更改为 bigint
alter talbe test change heigh int not null default 100;  # 将 heigh 列的属性更改为 not null 且默认值为100
alter talbe test alter heigh set default 100;  # 将 heigh 列的默认值改为100
alter talbe test alter heigh drop default;  # 将 heigh 列的默认值删除
alter talbe test engine=myisam;  # 将 test 表的类型更改为 myisam
alter talbe test rename to test2;  # 修改表名
alter table test drop foreign key CourseId;  # 删除外键

 auto_increment 自增序列
create table test(
  id int unsigned not null auto_increment;
);  # 创建表时设置为自增列,默认从1开始
create table test(
  id int unsigned not null auto_increment;
)engine=innodb auto_increment=100 charset=utf8;  # 从100开始
alter table test id auto_increment=100;  # 从100开始
#重置序列
   alter table test drop id;
   alter table test add id int unsigned not null auto_increment first,add primary key (id);

 > Oracle
select * from all_tab_comments       查询所有用户的表,视图等
select * from user_tab_comments      查询本用户的表,视图等
select * from all_col_comments       查询所有用户的表的列名和注释
select * from user_col_comments      查询本用户的表的列名和注释
select * from all_tab_columns        查询所有用户的表的列名等信息
select * from user_tab_columns       查询本用户的表的列名等信息

Q: => 的含义
A: => 是 Oracle 中调用存储过程的时候指定参数名进行调用
  一般指某些参数有默认值的时候你需要跳过某些参数来进行调用
  eg:
    CREATE OR REPLACE PROCEDURE HelloWorld3 (
        p_user_name VARCHAR2,
        p_val1 VARCHAR2 DEFAULT ' Good Moning,',
        p_val2 VARCHAR2 DEFAULT ' Nice to Meet you'
    )
    AS BEGIN
    dbms_output.put_line('Hello ' || p_user_name || p_val1 || p_val2 || '!');
    END HelloWorld3;

--查询指定条数的数据 > Oracle
SELECT * FROM customer WHERE ROWNUM < 101